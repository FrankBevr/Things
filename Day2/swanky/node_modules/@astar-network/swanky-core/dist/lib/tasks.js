"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTypes = exports.installDeps = exports.downloadNode = exports.processTemplates = exports.copyContractTemplateFiles = exports.copyTemplateFiles = exports.checkCliDependencies = void 0;
const tslib_1 = require("tslib");
const execa_1 = tslib_1.__importDefault(require("execa"));
const fs_extra_1 = require("fs-extra");
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const globby_1 = tslib_1.__importDefault(require("globby"));
const handlebars_1 = tslib_1.__importDefault(require("handlebars"));
const node_downloader_helper_1 = require("node-downloader-helper");
const node_process_1 = tslib_1.__importDefault(require("node:process"));
const decompress_1 = tslib_1.__importDefault(require("decompress"));
async function checkCliDependencies(spinner) {
    const dependencyList = [
        { dependencyName: "rust", versionCommand: "rustc --version" },
        { dependencyName: "cargo", versionCommand: "cargo -V" },
        {
            dependencyName: "cargo contract",
            versionCommand: "cargo contract -V",
        },
    ];
    for (const dep of dependencyList) {
        spinner.text(`  Checking ${dep.dependencyName}`);
        await execa_1.default.command(dep.versionCommand);
    }
}
exports.checkCliDependencies = checkCliDependencies;
async function copyTemplateFiles(templatesPath, contractTemplatePath, contractName, projectPath) {
    await (0, fs_extra_1.ensureDir)(projectPath);
    const commonFiles = await (0, globby_1.default)(`*`, { cwd: templatesPath });
    await Promise.all(commonFiles.map(async (file) => {
        await (0, fs_extra_1.copy)(node_path_1.default.resolve(templatesPath, file), node_path_1.default.resolve(projectPath, file));
    }));
    await (0, fs_extra_1.copy)(node_path_1.default.resolve(templatesPath, "patches"), node_path_1.default.resolve(projectPath, "patches"));
    await (0, fs_extra_1.rename)(node_path_1.default.resolve(projectPath, "gitignore"), node_path_1.default.resolve(projectPath, ".gitignore"));
    await copyContractTemplateFiles(contractTemplatePath, contractName, projectPath);
}
exports.copyTemplateFiles = copyTemplateFiles;
async function copyContractTemplateFiles(contractTemplatePath, contractName, projectPath) {
    await (0, fs_extra_1.copy)(node_path_1.default.resolve(contractTemplatePath, "contract"), node_path_1.default.resolve(projectPath, "contracts", contractName));
    await (0, fs_extra_1.copy)(node_path_1.default.resolve(contractTemplatePath, "test"), node_path_1.default.resolve(projectPath, "test", contractName));
}
exports.copyContractTemplateFiles = copyContractTemplateFiles;
async function processTemplates(projectPath, templateData) {
    const templateFiles = await (0, globby_1.default)(projectPath, {
        expandDirectories: { extensions: ["hbs"] },
    });
    handlebars_1.default.registerHelper("if_eq", function (a, b, options) {
        if (a === b) {
            // @ts-ignore
            return options.fn(this);
        }
        else {
            // @ts-ignore
            return options.inverse(this);
        }
    });
    await Promise.all(templateFiles.map(async (tplFilePath) => {
        const rawTemplate = await (0, fs_extra_1.readFile)(tplFilePath, "utf8");
        const template = handlebars_1.default.compile(rawTemplate);
        const compiledFile = template(templateData);
        await (0, fs_extra_1.rm)(tplFilePath);
        await (0, fs_extra_1.writeFile)(tplFilePath.split(".hbs")[0], compiledFile);
    }));
}
exports.processTemplates = processTemplates;
async function downloadNode(projectPath, nodeInfo, spinner) {
    const binPath = node_path_1.default.resolve(projectPath, "bin");
    await (0, fs_extra_1.ensureDir)(binPath);
    const dlUrl = nodeInfo.downloadUrl[node_process_1.default.platform];
    if (!dlUrl)
        throw new Error(`Could not download swanky-node. Platform ${node_process_1.default.platform} not supported!`);
    const dlFileDetails = await new Promise((resolve, reject) => {
        const dl = new node_downloader_helper_1.DownloaderHelper(dlUrl, binPath);
        dl.on("progress", (event) => {
            spinner.text(`Downloading Swanky node ${event.progress}%`);
        });
        dl.on("end", (event) => {
            resolve(event);
        });
        dl.on("error", (error) => {
            reject(new Error(`Error downloading node: , ${error.message}`));
        });
        dl.start().catch((error) => reject(new Error(`Error downloading node: , ${error.message}`)));
    });
    if (dlFileDetails.incomplete) {
        throw new Error("Node download incomplete");
    }
    if (dlFileDetails.filePath.endsWith(".tar.gz")) {
        const compressedFilePath = node_path_1.default.resolve(binPath, dlFileDetails.filePath);
        const decompressed = await (0, decompress_1.default)(compressedFilePath, binPath);
        const nodePath = node_path_1.default.resolve(binPath, decompressed[0].path);
        await (0, fs_extra_1.remove)(compressedFilePath);
        await execa_1.default.command(`chmod +x ${nodePath}`);
        return nodePath;
    }
    return node_path_1.default.resolve(binPath, dlFileDetails.filePath);
}
exports.downloadNode = downloadNode;
async function installDeps(projectPath) {
    let installCommand = "npm install";
    try {
        await execa_1.default.command("yarn --version");
        installCommand = "yarn install";
    }
    finally {
        await execa_1.default.command(installCommand, { cwd: projectPath });
    }
}
exports.installDeps = installDeps;
async function generateTypes(artifactsPath, destinationPath) {
    try {
        const targetPath = node_path_1.default.resolve(destinationPath, "typedContract");
        const targetPathExists = await (0, fs_extra_1.pathExists)(targetPath);
        if (targetPathExists) {
            await (0, fs_extra_1.remove)(targetPath);
        }
        await execa_1.default.command(`npx typechain-polkadot --in . --out typedContract`, {
            cwd: artifactsPath,
        });
        await (0, fs_extra_1.copy)(node_path_1.default.resolve(artifactsPath, "typedContract"), targetPath);
    }
    catch (error) {
        console.error(error);
    }
}
exports.generateTypes = generateTypes;
