"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyArtifactsFor = exports.getBuildCommandFor = exports.resolveNetworkUrl = exports.getSwankyConfig = exports.ensureSwankyProject = exports.commandStdoutOrNull = void 0;
const tslib_1 = require("tslib");
const execa_1 = tslib_1.__importDefault(require("execa"));
const fs = require("fs-extra");
const node_child_process_1 = require("node:child_process");
const path = require("node:path");
const consts_js_1 = require("./consts.js");
async function commandStdoutOrNull(command) {
    try {
        const result = await execa_1.default.command(command);
        return result.stdout;
    }
    catch {
        return null;
    }
}
exports.commandStdoutOrNull = commandStdoutOrNull;
async function ensureSwankyProject() {
    const configExists = await fs.pathExists("swanky.config.json");
    if (!configExists) {
        throw new Error("No 'swanky.config.json' detected in current folder!");
    }
}
exports.ensureSwankyProject = ensureSwankyProject;
async function getSwankyConfig() {
    try {
        const config = await fs.readJSON("swanky.config.json");
        return config;
    }
    catch {
        throw new Error("No 'swanky.config.json' detected in current folder!");
    }
}
exports.getSwankyConfig = getSwankyConfig;
function resolveNetworkUrl(config, networkName) {
    if (networkName === "") {
        return consts_js_1.DEFAULT_NETWORK_URL;
    }
    try {
        return config.networks[networkName].url;
    }
    catch {
        throw new Error("Network name not found in SwankyConfig");
    }
}
exports.resolveNetworkUrl = resolveNetworkUrl;
function getBuildCommandFor(language, contractPath) {
    if (language === "ink") {
        return (0, node_child_process_1.spawn)("npx", ["typechain-compiler"]);
    }
    if (language === "ask") {
        return (0, node_child_process_1.spawn)("npx", ["asc", "--config", `${contractPath}/asconfig.json`, `${contractPath}/index.ts`], { env: { ...process.env, ASK_CONFIG: `${contractPath}/askconfig.json` } });
    }
    throw new Error("Unsupported language!");
}
exports.getBuildCommandFor = getBuildCommandFor;
async function copyArtifactsFor(language, contractName, contractPath) {
    const ts = Date.now();
    const buildData = {
        timestamp: ts,
        artifactsPath: path.resolve("artifacts", contractName, ts.toString()),
    };
    await fs.ensureDir(buildData.artifactsPath);
    // const buildPaths = {
    //   ask: path.resolve(contractPath, "build"),
    //   ink: path.resolve(contractPath, "target", "ink"),
    // };
    if (language === "ink") {
        //copy artifacts/contract_name.contract and .json to artifactsPath .wasm and .json
        try {
            await Promise.all([
                fs.copyFile(path.resolve("artifacts", `${contractName}.contract`), `${buildData.artifactsPath}/${contractName}.wasm`),
                fs.copyFile(path.resolve("artifacts", `${contractName}.json`), `${buildData.artifactsPath}/${contractName}.json`),
            ]);
            //copy both to test/contract_name/artifacts
            const testArtifacts = path.resolve("test", contractName, "artifacts");
            const testTypedContracts = path.resolve("test", contractName, "typedContract");
            await fs.ensureDir(testArtifacts);
            await fs.ensureDir(testTypedContracts);
            await Promise.all([
                fs.copyFile(path.resolve("artifacts", `${contractName}.contract`), `${testArtifacts}/${contractName}.contract`),
                fs.copyFile(path.resolve("artifacts", `${contractName}.json`), `${testArtifacts}/${contractName}.json`),
                fs.move("typedContract", testTypedContracts, {
                    overwrite: true,
                }),
            ]);
        }
        catch (e) {
            console.error(e);
        }
    }
    else {
        await Promise.all([
            fs.copyFile(path.resolve(contractPath, "build", `${contractName}.wasm`), `${buildData.artifactsPath}/${contractName}.wasm`),
            fs.copyFile(path.resolve(contractPath, "build", "metadata.json"), `${buildData.artifactsPath}/${contractName}.json`),
        ]);
    }
    return buildData;
}
exports.copyArtifactsFor = copyArtifactsFor;
