"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainApi = void 0;
const api_1 = require("@polkadot/api");
const types_1 = require("@polkadot/types");
const AUTO_CONNECT_MS = 10000; // [ms]
class ChainApi {
    constructor(endpoint, silent = true) {
        this._provider = new api_1.WsProvider(endpoint, AUTO_CONNECT_MS);
        if (!silent)
            console.log("connecting to " + endpoint);
        this._api = new api_1.ApiPromise({
            provider: this._provider,
        });
        this._registry = new types_1.TypeRegistry();
        this._chainProperty = undefined;
    }
    get apiInst() {
        if (!this._api) {
            throw new Error("The ApiPromise has not been initialized");
        }
        return this._api;
    }
    get chainProperty() {
        return this._chainProperty;
    }
    get typeRegistry() {
        return this._registry;
    }
    async start() {
        this._api = await this._api.isReady;
        const chainProperties = await this._api.rpc.system.properties();
        const ss58Prefix = Number.parseInt((await this._api.consts.system.ss58Prefix).toString() || "0", 10);
        const tokenDecimals = chainProperties.tokenDecimals
            .unwrapOrDefault()
            .toArray()
            .map((i) => i.toNumber());
        const tokenSymbols = chainProperties.tokenSymbol
            .unwrapOrDefault()
            .toArray()
            .map((i) => i.toString());
        const chainName = (await this._api.rpc.system.chain()).toString();
        this._chainProperty = {
            tokenSymbols,
            tokenDecimals,
            chainName,
            ss58Prefix,
        };
    }
    async getBlockHash(blockNumber) {
        return this._api?.rpc.chain.getBlockHash(blockNumber);
    }
    buildTxCall(extrinsic, method, ...args) {
        const ext = this._api?.tx[extrinsic][method](...args);
        if (ext)
            return ext;
        throw new Error(`Undefined extrinsic call ${extrinsic} with method ${method}`);
    }
    buildStorageQuery(extrinsic, method, ...args) {
        const ext = this._api?.query[extrinsic][method](...args);
        if (ext)
            return ext;
        throw new Error(`Undefined storage query ${extrinsic} for method ${method}`);
    }
    wrapBatchAll(txs) {
        const ext = this._api?.tx.utility.batchAll(txs);
        if (ext)
            return ext;
        throw new Error("Undefined batch all");
    }
    wrapSudo(tx) {
        const ext = this._api?.tx.sudo.sudo(tx);
        if (ext)
            return ext;
        throw new Error("Undefined sudo");
    }
    async nonce(account) {
        return (await this._api?.query.system.account(account.pair.address))?.nonce.toNumber();
    }
    async getBalance(account) {
        return (await this._api?.query.system.account(account.pair.address)).data.free.toBn();
    }
    async signAndSend(signer, tx, options, handler) {
        // ensure that we automatically increment the nonce per transaction
        return tx.signAndSend(signer, { nonce: -1, ...options }, (result) => {
            // handle transaction errors
            result.events
                .filter((record) => Boolean(record.event) && record.event.section !== "democracy")
                .forEach(({ event: { data, method, section } }) => {
                if (section === "system" && method === "ExtrinsicFailed") {
                    const [dispatchError] = data;
                    let message = dispatchError.type.toString();
                    if (dispatchError.isModule) {
                        try {
                            const mod = dispatchError.asModule;
                            const error = dispatchError.registry.findMetaError(mod);
                            message = `${error.section}.${error.name}`;
                        }
                        catch (error) {
                            console.error(error);
                        }
                    }
                    else if (dispatchError.isToken) {
                        message = `${dispatchError.type}.${dispatchError.asToken.type}`;
                    }
                    const errorMessage = `${section}.${method} ${message}`;
                    console.error(`error: ${errorMessage}`);
                    throw new Error(message);
                }
                else if (section === "utility" && method === "BatchInterrupted") {
                    const anyData = data;
                    const error = anyData[1].registry.findMetaError(anyData[1].asModule);
                    const message = `${error.section}.${error.name}`;
                    console.error(`error: ${section}.${method} ${message}`);
                }
            });
            if (handler)
                handler(result);
        });
    }
}
exports.ChainApi = ChainApi;
