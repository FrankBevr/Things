"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeployApi = void 0;
const api_contract_1 = require("@polkadot/api-contract");
const substrate_api_1 = require("./substrate-api");
class DeployApi extends substrate_api_1.ChainApi {
    // eslint-disable-next-line no-useless-constructor
    constructor(endpoint) {
        super(endpoint);
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    async getGasCost() { }
    async deploy(abi, wasm, signerPair, gasLimit, args) {
        const code = new api_contract_1.CodePromise(this._api, abi, wasm);
        const storageDepositLimit = null;
        // TODO: make other constructor names passable by flag
        if (typeof code.tx.new !== "function") {
            throw new Error("Contract has no constructor called 'New'");
        }
        const tx = code.tx.new({ gasLimit, storageDepositLimit }, ...args);
        return new Promise((resolve, reject) => {
            this.signAndSend(signerPair, tx, {}, ({ status, events }) => {
                if (status.isInBlock || status.isFinalized) {
                    const instantiateEvent = events.find(({ event }) => event.method === "Instantiated");
                    const addresses = instantiateEvent?.event.data.toHuman();
                    if (!addresses || !addresses.contract)
                        reject(new Error("Unable to get the contract address"));
                    resolve(addresses.contract);
                    this._provider.disconnect();
                }
            });
        });
    }
}
exports.DeployApi = DeployApi;
